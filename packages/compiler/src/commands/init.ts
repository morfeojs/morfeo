import input from '@inquirer/input';
import * as fs from 'fs';
import * as path from 'path';
import { logger } from '../logger';
import { packageJson, consumerPackageJson } from '../utils';

export async function init() {
  let entryPoints: string;
  let cssPath: string;
  let instancePath: string;

  logger.announcement();

  try {
    entryPoints = await input({
      message: 'Where is your code?',
      default: './src/**/*.{ts,tsx,js,jsx}',
    });

    cssPath = await input({
      message: 'Where do you want to place the extracted CSS?',
      default: './src/styles/morfeo.css',
    });

    instancePath = await input({
      message: 'Where do you want to create the morfeo instance?',
      default: './src/morfeo.ts',
    });

    logger.whitespace();
  } catch {
    logger.warning('Aborted by user.');

    return process.exit(0);
  }

  await Promise.all([
    writeCssFile(cssPath),
    writeInstanceFile({
      cssPath: getRelativePath(instancePath, cssPath),
      entryPoints: getRelativePath(instancePath, entryPoints),
      instancePath,
    }),
    writeToGitIgnore(cssPath),
    updatePackageJson(instancePath),
  ]);

  logger.success('Morfeo has been initialized');
}

async function writeCssFile(targetPath: string) {
  try {
    await fs.promises.writeFile(
      path.join(process.cwd(), targetPath),
      '/* This file will be auto-generated by morfeo */',
    );

    logger.success(`CSS file created at ${targetPath}`);
  } catch {
    logger.error(`Error while creating CSS file at ${targetPath}`);
  }
}

async function writeInstanceFile({
  cssPath,
  entryPoints,
  instancePath,
}: {
  cssPath: string;
  entryPoints: string;
  instancePath: string;
}) {
  try {
    await fs.promises.writeFile(
      path.join(process.cwd(), instancePath),
      `import { createMorfeo } from '@morfeo/${
        isReactCodebase() ? 'react' : 'web'
      }';
  
export const morfeo = createMorfeo({
  entryPoints: ['${entryPoints}'],
  output: '${cssPath}'
});
`,
    );

    logger.success(`Morfeo instance file created at ${instancePath}`);
  } catch {
    logger.error(
      `Error while creating morfeo instance file at ${instancePath}`,
    );
  }
}

async function writeToGitIgnore(cssPath: string) {
  try {
    const gitIgnorePath = path.join(process.cwd(), '.gitignore');

    const gitIgnoreContent = await fs.promises.readFile(gitIgnorePath, {
      encoding: 'utf-8',
    });

    if (gitIgnoreContent.includes('# morfeo')) {
      logger.warning(`Morfeo CSS file seems already gitignored`);

      return;
    }

    await fs.promises.writeFile(
      gitIgnorePath,
      `${gitIgnoreContent}\n#morfeo\n${
        cssPath[0] === '.' ? '' : '.'
      }${cssPath.slice(1)}`,
    );

    logger.success(`Added morfeo CSS file to .gitignore`);
  } catch {
    logger.error(`Error while gitignoring morfeo files`);
  }
}

function isReactCodebase() {
  return (
    'react' in (consumerPackageJson.dependencies ?? {}) ||
    'react' in (consumerPackageJson.peerDependencies ?? {})
  );
}

function insertInOrder(object: object, key: string, value: string) {
  return Object.fromEntries(
    [...Object.entries(object), [key, value]].sort((first, second) => {
      return first[0].localeCompare(second[0]);
    }),
  );
}

function updatePackageJson(instancePath: string) {
  const dependency = isReactCodebase() ? '@morfeo/react' : '@morfeo/web';
  const devDependency = '@morfeo/compiler';

  const newPackageJson = { ...consumerPackageJson };

  newPackageJson['dependencies'] = insertInOrder(
    consumerPackageJson.dependencies || {},
    dependency,
    packageJson.version,
  );

  newPackageJson['devDependencies'] = insertInOrder(
    consumerPackageJson.devDependencies || {},
    devDependency,
    packageJson.version,
  );

  newPackageJson['scripts'] = {
    ...consumerPackageJson['scripts'],
    'dev:morfeo': `morfeo extract ${instancePath} --watch`,
    'build:morfeo': `morfeo extract ${instancePath}`,
  };

  return fs.promises.writeFile(
    path.join(process.cwd(), 'package.json'),
    JSON.stringify(newPackageJson, undefined, 2) + '\n',
  );
}

function getRelativePath(fromPath: string, toPath: string) {
  const relativePath = path.relative(path.dirname(fromPath), toPath);
  return relativePath.startsWith('./') ? relativePath : `./${relativePath}`;
}
